**事件循环（event loop）和消息队列（task queue）**

事件循环 机制和 消息队列 的维护是由事件触发线程控制的。
JS 引擎线程遇到异步（DOM 事件监听、网络请求、setTimeout 计时器等...），
会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击 DOM），
然后由事件触发线程将异步对应的回调函数加入到消息队列中，消息队列中的回调函数等待被执行。
同时，JS 引擎线程会维护一个执行栈，同步代码会依次加入执行栈然后执行，结束会退出执行栈。
如果执行栈里的任务执行完成，即执行栈为空的时候（即 JS 引擎线程空闲），事件触发线程才会从消息队列取出一个任务（即异步的回调函数）放入执行栈中执行。
执行完了后，执行栈再次为空，事件触发线程会重复上一步操作，再取出一个消息队列中的任务，**这种机制就被称为事件循环（event loop）机制。**

**宏任务与微任务**
宏任务（macrotask）
定时触发器线程(宏任务(异步任务))
setTimeout
setInterval
setImmediate
requestAnimationFrame
事件触发线程(宏任务(异步任务))
异步 http 请求线程(宏任务(异步任务))
script 方法(宏任务(同步任务))
new Promise(宏任务(同步任务)) 立即执行
微任务（microtask）
由于 Es6 和 node 出现产生的微任务

Promise.then() catch() finally(),一旦一个 pormise 有了结果,回调产生一个微任务
process.nextTick
MutationObserver
执行机制

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
5. 渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取）
   `html https://www.cnblogs.com/sunidol/p/11301785.html`
